# -*- coding: utf-8 -*-import torch as thfrom sklearn import metricsimport sysdef confusion_matrix(pred, label, thr):    pred_label = (pred > thr).type(th.float32)    # TODO: 实现混淆矩阵中 TP, FP, TN, FN 的计算    TP = th.logical_and(label == 1, pred_label == 1).sum().item()    FP = th.logical_and(label == 1, pred_label == 0).sum().item()    TN = th.logical_and(label == 0, pred_label == 1).sum().item()    FN = th.logical_and(label == 0, pred_label == 0).sum().item()    '''    pred_label = (pred > thr).type(th.int8)    # TODO: 实现混淆矩阵中 TP, FP, TN, FN 的计算    label = label.type(th.int8)    assert pred_label.dtype == label.dtype == th.int8    # 实现混淆矩阵中 TP, FP, TN, FN 的计算    result = pred_label ^ label   # 预测值和真实值异或计算    # bincount:需要一维整型张量    result_count = th.bincount(result)  # 0、1标签值 数量统计    # 真阳性，实际标签为1预测标签为1    TP = th.count_nonzero(label & pred_label)     # 交运算    # 假阳性，实际标签为0，预测标签为1    FP = th.count_nonzero(~label & pred_label)    # 真阴性，实际标签为0，预测标签为0    TN = result_count[0] - TP    # 假阴性，实际标签为1，预测标签为1    FN = result_count[1] - FP    '''    '''    TP = pred_label * label             # True Positive    FP = pred_label * (1 - label)       # False Positive    TN = (1 - pred_label) * label       # True Negative    FN = (1 - pred_label) * (1 - label) # False Negative    '''    return TP, FP, TN, FNdef classification_metric(pred, label, thr):    assert pred.ndim == 1 and label.ndim == 1, '输入必须为一维向量'    TP, FP, TN, FN = confusion_matrix(pred, label, thr)    sample_size = pred.shape[0]    # TODO: 实现 accuracy, precision, recall, F1 score 的计算    # 注意：为了避免除零，在分母加上 sys.float_info.epsilon    # 准确率    accuracy = (TP + TN)/(TP + FP + TN + FN + sys.float_info.epsilon)    # 查准率    precision = TP / (TP + FP+ sys.float_info.epsilon)    # 查全率    recall = TP / (TP + FN + sys.float_info.epsilon)    # F1值    F1 = (2 * precision * recall) / (precision + recall + sys.float_info.epsilon)    return accuracy, precision, recall, F1            def roc_metric(pred, label):    assert pred.ndim == 1 and label.ndim == 1, '输入必须为一维向量'    # 从大到小排列预测值，label也要相应调整    idx = th.argsort(pred, descending=True)    pred = pred[idx]    label = label[idx]    # TPR = TP / (TP + FN), FPR = FP / (TN + FP)    thresholds = pred.tolist()    thresholds.append(0)    tpr = []    fpr = []    for thr in thresholds:        TP, FP, TN, FN = confusion_matrix(pred, label, thr)        tpr.append(TP / (TP + FN + sys.float_info.epsilon))        fpr.append(FP / (TN + FP + sys.float_info.epsilon))            # ROC 曲线下面积    auc = metrics.auc(fpr, tpr)    return auc, tpr, fpr, thresholdsif __name__ == '__main__':    pred = th.tensor([0.9, 0.8, 0.1, 0.3, 0.8])    label = th.tensor([1, 1, 0, 1, 1])    thr = 0.5    confusion_matrix(pred, label, thr)            